# 常用五大算法设计方法
## 分治法
计算机科学中分枝法是一个很重要的算法，即分而治之。     
**任何一个可以用计算机求解的问题所需的计算时间都与其规模有关**，问题的规模越小，越容易直接求解，解决问题所用的时间越少。     

分治法的设计思想：**将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之**。     
分治策略：对于一个规模为N的问题，若该问题可以容易地解决，则直接解决，否则将其分解为K个规模较小的子问题这些**子问题相互独立且与原问题形式相同**，递归地解决这些子问题，然后将**各个子问题的解合并得到原问题的解**，这种算法设计策略叫做**分治法**。     
### 分治法所能解决的问题的特征：
- 该问题的规模缩小到一定程度就可以很容易的解决；
- 该问题可以分解为若干个规模较小的相同问题，即该问题具有**最优子结构**性质；*（前提）*
- **利用该问题分解出的子问题的解可以合并为该问题的解**；*（关键）*
- 该问题所分解出的各个子问题是**相互独立的**，即子问题之间不包含公共的子子问题。
### 分治法的基本步骤
#### 分治法在每一层递归上都有三个步骤：
1. 分解：将原问题分解为若干个规模小的，相互独立，与原问题形式相同的子问题；
2. 解决：若子问题规模较小而容易被解决则直接解，否则递归的解各个子问题；
3. 合并：将各个子问题的解合并为原问题的解。
#### 分治法的应用
- 递归与HANOI塔的问题；
- 二分法求方程近似解；
- 用C++实现合并排序；
- 求最大值和最小值的分治算法；
## 动态规划法
1951年美国数学家*R.Bellman*等人，根据一类多阶段问题的特点，把**『多阶段决策』问题变换为一系列互相联系的『单阶段问题』，然后逐个加以解决**。而且一些静态模型，只要人为的引进『时间』因素，分成时段，就可以转化成多阶段的动态模型，用动态规划方法去处理。     
**最优化原理**：假设为了解决某一优化问题，需要依次作出n个决策D1,D2,...,DN,如若这个决策序列是最优的，对于任何一个整数K，1 \< K \< N，不论前面K个决策是怎样的，以后的最优策略只取决于前面决策所确定的当前状态，即以后的决策DK+1,DK+2,...,DN也是最优的。     
### 动态规划最优化原理的的条件：
- 问题中的状态必须满足最优化原理；
- 问题中的状态必须满足无后效性；     

**无后效性**：下一时刻的状态只与当前状态有关，而和当前状态之前的状态无关，当前状态是对以往决策的总结。     
*初始状态 -> 决策1 -> 决策2 -> ... -> 决策N -> 结束状态*       
### 动态规划决策过程示意图
1. **划分阶段**：按照问题的时间或空间特征，将问题划分为若干个阶段；*（阶段有序或可排序）*
2. **确定状态和状态变量**：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来；*（状态的选择具有无后性）*
3. **确定决策并写出状态转移方程**：:因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两段各状态之间的关系来确定决策；
4. **寻找边界条件**：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。
### 动态规划算法的应用
- 动态规划求0/1背包问题
- 最长公共子串问题的实现
- 用动态规划实现导弹拦截
- 最大化投资回报问题的实现
### 算法实现
动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要的就是确定动态规划三要素：问题的阶段,每个阶段的状态以及从前一个阶段转化到后一个阶段之间的递推关系。递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。下面分别以求解最大化投资回报问题和最长公共子序列问题为例阐述用动态规划算法求解问题的一般思路。     
## 贪心算法
所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。     
### 贪心算法的基本思路
1. 建立数学模型来描述问题；
2. 把求解的问题分成若干子问题；
3. 对每一个问题求解，得到子问题的局部最优解；
4. 把子问题的局部最优解合成原来解问题的一个解。
### 实现该算法的过程
1. 从问题的某一初始解出发；
2. while能朝给定总目标前进一步do；
3. 求出可行解的一个解元素；
4. 由所有解元素组合成问题的一个可行解。
### 例题：
有一个背包，背包容量是M=150.有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。     
- 物品： A、 B、 C、 D、 E、 F、 G
- 重量：35、30、60、50、40、10、25
- 价值：10、40、30、50、35、40、30
#### 分析
目标函数：*pi和最大*（价值最大）     
约束条件是装入的**物品总重量**不超过背包容量：*wi\<=M*（重量）     
- 根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？
- 每次挑选所占重量最小的物品装入是否最优？
- 每次挑选单位重量价值最大的物品，成为解本题的策略。     

值得注意的是，贪心算法并不是完全不可以使用，**贪心策略一旦经过证明成立后**，它就是一种高效的算法。贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。可惜的是，**它需要证明后才能真正运用到题目的算法中**。     
**一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。**     
